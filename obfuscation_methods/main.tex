\documentclass[xcolor=dvipsnames]{beamer}

%packages
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage[english, greek]{babel}
\usepackage{csquotes}

\newcommand{\lt}{\latintext}
\newcommand{\gt}{\greektext}
\newcommand{\ios}{\dot{\imath}\mathcal{O}}
\newcommand{\io}[1]{\dot{\imath}\mathcal{O}(#1)}
\newcommand{\As}{\mathcal{A}}
\newcommand{\A}[1]{\mathcal{A}(#1)}

\definecolor{cyan}{rgb}{0.0, 0.49411764705882355, 0.5215686274509804}

\usecolortheme[named=cyan]{structure}

\hypersetup{
    colorlinks = true,
    linkcolor  = cyan,
    filecolor  = cyan,      
    urlcolor   = cyan,
}

\title{\gt Μέθοδοι Συσκότισης Κώδικα}
\author{Δημήτριος Υφαντίδης (ΑΕΜ:3938)\\
\lt ydimitri@csd.auth.gr}
\institute{Αριστοτέλειο Πανεπιστήμιο Θεσσαλονίκης, \\
Τμήμα Πληροφορικής της Σχολής Θετικών Επιστημών}
\date{9 Μαΐου 2023}

\begin{document}

\frame{\titlepage}

\begin{frame}{Εισαγωγή}

Η Συσκότιση είναι η απόκρυψη του επιδιωκόμενου νοήματος της επικοινωνίας, καθιστώντας το μήνυμα δυσνόητο, συνήθως με συγκεχυμένη και διφορούμενη γλώσσα. 

\hfill

Όπως και η κρυπτογράφηση, συνεισφέρει στην προστασία ενός συνόλου δεδομένων από κακόβουλες οντότητες. Όμως, η συσκότιση και η κρυπτογράφηση είναι δυο έννοιες διαφορετικές  που δεν πρέπει να συγχέονται.

\end{frame}

\begin{frame}{Συσκότιση και Κρυπτογράφηση}

Η κρυπτογράφηση ασχολείται με την αλλαγή δεδομένων  σε άλλα δεδομένα για την πλήρη απόκρυψη του αρχικού μηνύματος. Η συσκότιση είναι η απόκρυψη του σκοπού ή του νοήματος των δεδομένων χωρίς να αλλάζουν τα ίδια τα δεδομένα. 

\hfill

Στόχος της συσκότισης δεν είναι να κάνει αδύνατη την κατανόηση ενός μηνύματος, αλλά να προκαλέσει συμφόρηση σε όποιον το προσπαθήσει.

\hfill 

{\lt
\begin{itemize}
	\item \textbf{\gt Συσκότιση: } 
	
	``The President has arrived" $\rightarrow$ ``The Eagle has landed"
	
	\item \textbf{\gt Κρυπτογράφηση: } 
	
	``The President has arrived" $\rightarrow$ ``buwtixwvfvliaignbvgciu"
\end{itemize}
}
\end{frame}

\begin{frame}{Συσκότιση Κώδικα Λογισμικού}
Στην ανάπτυξη λογισμικού, η συσκότιση είναι η πράξη της δημιουργίας πηγαίου κώδικα ή κώδικα μηχανής που είναι δύσκολο να κατανοηθεί από ανθρώπους ή υπολογιστές. 

\hfill

Όπως και η απόκρυψη στη φυσική γλώσσα, μπορεί να χρησιμοποιεί περιττές ή/και δυσνότηες (αλλά ισοδύναμες) εκφράσεις για τη σύνθεση δηλώσεων. 

\end{frame}

\begin{frame}{Συσκότιση Κώδικα Λογισμικού}

Οι προγραμματιστές μπορεί να αποκρύψουν σκόπιμα τον ιδιόκτητο κώδικά τους για να αποκρύψουν τον σκοπό του (ασφάλεια μέσω αδιαφάνειας) ή τη λογική του, κυρίως για να αποτρέψουν τόσο την παραποίηση, όσο και το {\lt reverse engineering} καθώς και να προστατέψουν τα πνευματικά δικαιώματά τους.

\hfill

Αυτό μπορεί να γίνει χειροκίνητα ή με τη χρήση ενός αυτοματοποιημένου εργαλείου, με την τελευταία να είναι η προτιμώμενη τεχνική στη βιομηχανία (π.χ. \href{https://www.guardsquare.com/proguard}{\lt ProGuard}, \href{https://www.libhunt.com/r/javascript-obfuscator}{\lt javascript-obfuscator}).

\end{frame}

\begin{frame}{Συσκότιση Κώδικα Λογισμικού}

Πρώτοι αριθμοί $<$ 1000
\includegraphics[scale=.5]{images/obf1}

\hfill

Πρώτοι 10 όροι της ακολουθίας {\lt Fibonacci}
\includegraphics[scale=.45]{images/obf2}

\hfill

{\lt Mandelbrot set}
\includegraphics[scale=.45]{images/obf3}

\hfill

{\lt source: \href{https://docs.python.org/3/faq/programming.html\#is-it-possible-to-write-obfuscated-one-liners-in-python}{Python Programming FAQ}}


\end{frame}

\begin{frame}{Μέθοδοι Συσκότισης Κώδικα}
\begin{itemize}
	\item Αναδιάταξη κώδικα
	\item Αλλαγή ονομάτων μεταβλητών {\lt (identifier renaming)}
	\item Εισαγωγή πλεοναστικού/αχρείαστου κώδικα
	\item Εισαγωγή μεταπηδήσεων {\lt (conditional, unconditional)}
	\item Εκ νέου ανάθεση μεταβλητών {\lt (identifier reassigning)}
	\item Κωδικοποίηση συμβολοσειρών
	\item Παραποίηση της ροής ελέγχου
	\item Συνδυασμός των παραπάνω τεχνικών
\end{itemize}
\end{frame}

\begin{frame}{Μέθοδοι Συσκότισης Κώδικα}
Αλλαγή ονομάτων μεταβλητών:
\includegraphics[scale=0.5]{images/rename_obf}

\hfill

{\lt source: \href{https://www.preemptive.com/obfuscation/}{\lt ``What is Code Obfuscation?"}}
\end{frame}

\begin{frame}{Μέθοδοι Συσκότισης Κώδικα}
Παραποίηση ροής του ελέγχου:
\includegraphics[scale=0.5]{images/control_flow_obf}

\hfill

{\lt source: \href{https://www.preemptive.com/obfuscation/}{\lt ``What is Code Obfuscation?"}}
\end{frame}

\begin{frame}{Συσκότιση - Επιστημονική Σκοπιά}
\begin{itemize}
	\item \textbf{Συσκότιση μαύρου κουτιού:}
	
	Κρυπτογραφικό πρωτότυπο που θα επέτρεπε σε ένα πρόγραμμα υπολογιστή να συσκοτιστεί με τέτοιο τρόπο ώστε να είναι αδύνατο να προσδιοριστεί οτιδήποτε γι' αυτό εκτός από τη συμπεριφορά εισόδου και εξόδου του. Αποδείχθηκε ότι είναι αδύνατη, έστω και θεωρητικά. \pause
	
	\hfill	

	\item \textbf{Συσκότιση μη-διακρισιμότητας:}
	
	Συμβολίζεται με $\ios$ ({\lt Indistinguishability Obfuscation}). Έχει την καθοριστική ιδιότητα ότι η απόκρυψη οποιωνδήποτε δύο προγραμμάτων που υπολογίζουν την ίδια μαθηματική συνάρτηση οδηγεί σε προγράμματα που δεν μπορούν να διακριθούν το ένα από το άλλο.
\end{itemize}
\end{frame}


\begin{frame}{\lt Black Box Obfuscation}
Υπόθεση:
\begin{itemize}
	\item $\vec{\alpha}, \vec{\beta}\: \in \{0,\:1\}^{k}$, με $\vec{\beta} \neq \vec{0}$
	\item $C:\;\{0,\:1\}^{k} \rightarrow \{0,\:1\}^{k}$ με
	\[ 
	C(\vec{x})= \left\{
	\begin{array}{ll}
      \vec{\beta} & \text{για } \vec{x} = \vec{\alpha} \\
      \vec{0} & \text{για } \vec{x} \neq \vec{\alpha}\\
	\end{array} 
	\right. 
	\]
	\item $Z: \;\{0,\:1\}^{k} \rightarrow \{0,\:1\}^{k}$ με $Z(\vec{x})\;=\; \vec{0},\;\; \forall \vec{x} \in \{0,\:1\}^{k}$
	\item $D:\;{(\{0,\:1\}^{k})}^{\{0,\:1\}^{k}} \rightarrow \{0,\:1\}$ με
	\[ 
	D(\mathcal{X})= \left\{
	\begin{array}{ll}
      1 & \text{για } \mathcal{X}(\vec{\alpha}) = \vec{\beta} \\
      0 & \text{για } \mathcal{X}(\vec{\alpha}) \neq \vec{\beta}\\
	\end{array} 
	\right\rvert \;\; time(\mathcal{X}) \leq poly(k)
	\]
	\item $\mathcal{BBO}$ ένας {\lt black box obfuscator} όπου $\mathcal{BBO}(P)$ η συσκότιση μαύρου κουτιού του $P$ για κάθε πρόγραμμα $P$.
	\item $C' \leftarrow \mathcal{BBO}(C)$ και $D' \leftarrow \mathcal{BBO}(D)$
\end{itemize}
\end{frame}

\begin{frame}{\lt Black Box Obfuscation}
Αποδυκνείεται ότι υπάρχει πρόγραμμα που δεν μπορεί να συσκοτιστεί από τον $\mathcal{BBO}$, άρα δεν υπάρχει συσκότιση μαύρου κουτιού.\pause \\

\hfill

\textbf{Απαγωγή σε άτοπο (α' μέρος):}\\
Έστω ότι ο επιτιθέμενος έχει πρόσβαση μόνο στο πρόγραμμα $C'$, τότε είναι πρακτικά αδύνατον να βρει τον κωδικό $\alpha$, δηλαδή:
\[
	Pr[C(\vec{x_0}) = \vec{\beta} \;|\; \vec{x_0} \xleftarrow{\$} \{0,\:1\}^{k}]\;\;=\;\; 2^{-k}
\]
δηλαδή $\simeq 0$ για (όχι και τόσο) μεγάλο $k$, π.χ. $k > 50$. Άρα δεν μπορεί να ξεχωρίσει το $C'$ από το $Z$ σε πολυωνυμικό χρόνο επειδή $C'(\vec{x_0}) = Z(\vec{x_0}) = \vec{0}$, για κάθε $\vec{x_0} \in \{0,\:1\}^{k}$ εντός πολυωνυμικού χρονικού περιθωρίου.
\end{frame}

\begin{frame}{\lt Black Box Obfuscation}
\textbf{Απαγωγή σε άτοπο (β' μέρος):}\\
Όμως, αν έχει πρόσβαση και στο $D'$ μπορεί να εξάγει το συμπέρασμα ότι $D'(C') = 1$ ενώ $D'(Z) = 0$, άρα μπορεί να διακρίνει ότι η εσωτερική υλοποίηση του $C'$ \underline{δεν} είναι αυτή του $Z$. Επομένως, γνωρίζει παραπάνω πράγματα για το $C'$ πέρα από τη συμπεριφορά εισόδου-εξόδου. 
Τα προγράμματα $C$ και $D$ μπορούν να εννοποιηθούν στο πρόγραμμα:

\[
	F(m,\:\vec{x}) \coloneqq \left\{
	\begin{array}{ll}
      C(\vec{x}) & \text{για } m = 0 \\
      D(C) & \text{για } m = 1\\
	\end{array} 
	\right.
\]
ή αλλιώς
\[
	F(\mathcal{X},\:m,\:\vec{x}) \coloneqq \left\{
	\begin{array}{ll}
      \mathcal{X}(\vec{x}) & \text{για } m = 0 \\
      D(\mathcal{X}) & \text{για } m = 1\\
	\end{array} 
	\right.
\]
Άρα, με βάση τα προηγούμενα $\nexists\:\mathcal{BBO}(F)$.
\end{frame}

\begin{frame}{Συμβιβασμός}
\textbf{Η καλύτερη δυνατή Συσκότιση:}\\
Ο {\lt obfuscator} $\mathcal{O}$ λέγεται βέλτιστος όταν εγγυάται ότι κάθε πληροφορία που δεν κρύβεται από το συσκοτισμένο πρόγραμμα,  δεν αποκρύπτεται ούτε από οποιοδήποτε άλλο πρόγραμμα ίδιου μεγέθους που υπολογίζει την ίδια λειτουργία. Έτσι η συσκότιση είναι (κυριολεκτικά) η καλύτερη δυνατή.

\hfill

Αυτό επιτυγχάνεται μέσω της παραλαγής της συσκότισης μαύρου κουτιού, της συσκότισης \textbf{μη διακρισιμότητας}. 

\end{frame}

\begin{frame}{\lt Indistinguishability Obfuscation}
Έστω $\ios$ κάποιος ομοιόμορφος πιθανοτικός αλγόριθμος πολυωνυμικού χρόνου. Τότε ο $\ios$ ονομάζεται {\lt Indistinguishability Obfuscator} αν και μόνο αν ικανοποιεί τις συνθήκες \textbf{Πληρότητας} και \textbf{Μη Διακρισιμότητας}, δηλαδή: \pause

\hfill

\begin{enumerate}
	\item Για κάθε λογικό κύκλωμα $C(\vec{x}): \{0,\:1\}^{n} \rightarrow \{0,\:1\}$, ισχύει:
	\[
		Pr[C'(\vec{x}) = C(\vec{x}): C' \leftarrow \io{C}] = 1
	\] \pause \vspace{-0.2in}
	\item Για κάθε ζεύγος λογικών κυκλωμάτων $C_0,\:C_1$ ίδιου μεγέθους και για κάθε εχθρικό, πιθανοτικό αλγόριθμο πολυωνυμικού χρόνου, $\As$ {\lt (adversary)}:
	\[
		Pr[\A{\io{C_0}}=1]\; \simeq\; Pr[\A{\io{C_1}}=1]
	\]
	Δηλαδή, ο $\As$ δεν μπορεί να διακρίνει αν το αρχικό πρόγραμμα είναι το $C_0$ ή το $C_1$. 
\end{enumerate}

\end{frame}

\begin{frame}{Ύπαρξη του $\ios$}
Το αν είναι δυνατόν να υπάρξει ένας $\ios$ {\lt obfuscator} εξαρτάται από τις απαντήσεις σε άλλα ανοιχτά ερωτήματα της επιστήμης υπολογιστών, όπως η ύπαρξη των \textbf{{\lt One-way functions}} και η απάντηση στο \textbf{{\lt P vs NP}}. Όλες οι σημερινές υλοποιήσεις βασίζονται σε ευρετικές μεθόδους.\pause

\hfill

Οι \enquote{πέντε κόσμοι} του {\lt Russell Impagliazzo}:
\begin{enumerate}
	\item \textbf{{\lt Algorithmica:}} {\lt P = NP}, υπάρχει $\ios$
	\item \textbf{{\lt Heuristica:}} Τα {\lt NP} προβλήματα είναι σχετικά εύκολα, δεν υπάρχει $\ios$
	\item \textbf{{\lt Pessiland:}} {\lt BPP} $\neq$ {\lt NP}, δεν υπάρχουν {\lt one-way functions}, δεν υπάρχει $\ios$
	\item \textbf{{\lt Minicrypt:}} υπάρχουν {\lt one-way functions}, δεν υπάρχει ασφαλής κρυπτογραφία δημοσίου κλειδιού, δεν υπάρχει $\ios$
	\item \textbf{{\lt Cryptomania:}} υπάρχει ασφαλής κρυπτογραφία δημοσίου κλειδιού, δεν υπάρχει $\ios$
	\item {\lt (extra)} \textbf{{\lt Obfustopia:}} υπάρχει $\ios$
\end{enumerate}

\end{frame}

\begin{frame}{Βιβλιογραφικές Αναφορές}

\begin{enumerate}
	\item {\lt Wikipedia}\\
	\href{https://en.wikipedia.org/wiki/Black-box_obfuscation}{\textit{\lt ``Black-Box obfuscation"}} \\
	\href{https://en.wikipedia.org/wiki/Indistinguishability_obfuscation}{\textit{\lt ``Indistinguishability obfuscation"}}
	\item {\lt Wikibooks}\\
	\href{https://tinyurl.com/43u57azu}{\textit{\small{\lt ``}Τεχνική Νομοθεσία Για Μηχανικούς Πληροφορικής/Τεχνικά μέσα για την προστασία του λογισμικού από παράνομη αντιγραφή - πειρατεία{\lt "}}}
	\item {\lt Aayush Jain; Huijia Lin; Amit Sahai} (2021)\\
	\href{https://dl.acm.org/doi/pdf/10.1145/3406325.3451093}{\textit{\lt \small ``Indistinguishability Obfuscation from Well-Founded
Assumptions"}}
	\item {\lt Tim Robinson} (2022)\\
	\href{https://cybersynchs.com/obfuscation-vs-encryption/}{\textit{\lt ``Obfuscation Vs. Encryption (Easily Explained)"}}
	\item {\lt Chandan Kumar Behera; D. Lalitha Bhaskari} (2015)\\
	\href{https://tinyurl.com/2p8cuumm}{\textit{\lt ``Different Obfuscation Techniques for Code Protection"}}
\end{enumerate}
\end{frame}

\begin{frame}{Βιβλιογραφικές Αναφορές}
\begin{enumerate}
\setcounter{enumi}{5}
	\item {\lt Boaz Barak; Oded Goldreich; Russell Impagliazzo; Steven Rudich; Amit Sahai; Salil Vadhan; Ke Yang (2010)`}\\
	\href{https://www.boazbarak.org/Papers/obfuscate.pdf}{\textit{\lt ``On the (Im)possibility of Obfuscating Programs"}}
	\item {\lt  Valentine Kabanets; Shawn Andrews (2011)}\\
	\href{https://tinyurl.com/2p8z8zja}{\textit{\small \lt ``based on `A Personal View of Average Case Complexity' by R. Impagliazzo, 1995"}}
	\item {\lt Shafi Goldwasser; Guy N. Rothblum}\\
	\href{https://www.microsoft.com/en-us/research/wp-content/uploads/2007/01/GoldwasserR07.pdf}{\textit{\lt ``On Best-Possible Obfuscation"}}
\end{enumerate}

\end{frame}

\end{document}